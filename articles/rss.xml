<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Articles on Yanaël Barbier</title><link>https://yanael.io/articles/</link><description>Recent content in Articles on Yanaël Barbier</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 10 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://yanael.io/articles/rss.xml" rel="self" type="application/rss+xml"/><item><title>Application vs infrastructure level</title><link>https://yanael.io/articles/application-vs-infrastructure-level/</link><pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate><guid>https://yanael.io/articles/application-vs-infrastructure-level/</guid><description>&lt;p>&lt;em>TL;DR: Choosing at which level between application or infrastructure you will act is an early and fundamental decision for your product, it needs to be carefully decided because it will impact the business broadly.&lt;/em>&lt;/p>
&lt;h2 id="saas">SaaS&lt;/h2>
&lt;p>Software as a Service is the approach that lets you &lt;strong>build the way you want&lt;/strong> without worrying about the support of multi-platforms.&lt;/p>
&lt;p>Technical compatibility appears in the integration part but not on the design decisions made inside the product. You can choose your language, stack, structure, practices, to make your service run.&lt;/p>
&lt;p>In short: you can &lt;strong>focus on the business needs&lt;/strong>, not on the requirements due to the technical debt of your clients.&lt;/p>
&lt;h2 id="serve-or-distribute">Serve or Distribute&lt;/h2>
&lt;p>Software as a Service implies to serve your service, it can then be called via a network and/or the Internet. Certain services are accessible through a web interface others will have an API to access it. In this pattern, the service needs to be online.&lt;/p>
&lt;p>But there is a different approach to provide your software: &lt;strong>bundling and distributing it&lt;/strong>. Like the current application model on your phone and the famous AppStore. Your application is prepared, bundled, and sent to the store where people can download it and use it directly on their phones. This model allows the offline mode. Some challenges will hit when an update has to be done. Now it only relies on the user if they did or not the update. You can &lt;strong>combine the two models to enable your full product potential.&lt;/strong>&lt;/p>
&lt;h2 id="architecture">Architecture&lt;/h2>
&lt;p>The way you provide your software can have an impact on the overall architecture. If you choose to have an online service where users can connect to it and use your product directly, you can design your service as one product that can &lt;strong>support multiple users&lt;/strong>, or a product that can &lt;strong>support one user&lt;/strong> but you start multiple instances of your product to serve more clients.&lt;/p>
&lt;p>A simple representation of the architecture:&lt;/p>
&lt;p>&lt;em>Multi-tenancy, multi-client product:&lt;/em>&lt;/p>
&lt;pre>&lt;code>- Product
- Client 1
- User 1
- User n
- Client 2
- User 1
- User n
- Client n
- ...
&lt;/code>&lt;/pre>&lt;p>&lt;em>&lt;em>Multi-instance, single client product:&lt;/em>&lt;/em>&lt;/p>
&lt;pre>&lt;code>- Product: Instance for client 1
- User 1
- User n
- Product: Instance for client 2
- User 1
- User n
- Product: Instance for client n
...
&lt;/code>&lt;/pre>&lt;p>These two models of architecture imply a lot of differences under the hood and come with their advantages and constraints. It has an impact at a different level.&lt;/p>
&lt;p>The first approach manages the multi-tenant at an application level, the second one handles the multi-tenant at an infrastructure level.&lt;/p>
&lt;p>This has an impact at different levels of the stack:&lt;/p>
&lt;p>&lt;em>Levels:&lt;/em>&lt;/p>
&lt;pre>&lt;code>+-------------+
| Product | &amp;lt;- Application level
|-------------|
| Instance | &amp;lt;- Infrastructure level
+-------------+
&lt;/code>&lt;/pre>&lt;p>If you want to handle multi-tenants at an application level, you have to build the &lt;strong>permissions system into the application itself&lt;/strong>, define what a user can do and access. The limit and boundaries live inside the application.&lt;/p>
&lt;p>At an infrastructure level, the application is not touched and the boundaries between users are made into the infrastructure configuration, like a new server or networking settings.&lt;/p>
&lt;p>Acting at a different level has an impact on the business itself, the resources allocated will be different, and the teams will require a different skillset. At an application level, Software Engineers are more involved, and at an infrastructure level, DevOps will be the main actors.&lt;/p>
&lt;p>As well, designing your product at an infrastructure level can allow flexibility in terms of distribution. Your product can be instanced in another place on another server. But with this approach, some constraints exist. The communication between clients will be more complex. It can be an advantage to keep your client data separated but features that federate data and allow interaction can be more complex to build.&lt;/p>
&lt;p>Regarding data storage, at an application level, you can create one central database where all the tenants&amp;rsquo; data is stored. The separation can be made into the database with different users, tables and schemas.&lt;/p>
&lt;p>At an infrastructure level, you have to deploy a new database per client and manage this database independently from the other DBs. So the data is well separated but it will not allow you to do cross tenant queries. If you want to aggregate data from every client you have to run a query on each DB. Also, sharing common data requires a different approach: instead of using one table and allowing all the users to query it, the table needs to be available in another common DB or duplicated into each DB.&lt;/p>
&lt;h3 id="deployment-of-a-new-version">Deployment of a new version&lt;/h3>
&lt;p>When you work at an application level, all the clients can get access to the latest version of your product as soon as you release it.&lt;/p>
&lt;p>At an infrastructure level, releasing a new version means deploying a new version for each client independently.&lt;/p>
&lt;p>This question between application level and infrastructure level is becoming more obvious when you have to work on-premise. Deploying an application on the client infrastructure directly brings new challenges and if you have built a multi-tenant application it will not make sense to deploy that application on the client infrastructure. Indeed, you want to distribute only one instance of the application to the client and not a system to manage multiple instances of the application.&lt;/p>
&lt;p>With that in mind, this kind of distribution will impact the design of the application.&lt;/p>
&lt;p>Designing an application to be able to run either as SaaS or on-premise requires a different architecture and comes with new challenges to solve.&lt;/p>
&lt;p>If you want to distribute the &lt;strong>same product to multiple clients&lt;/strong>, the challenges you have to solve are:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Version management:&lt;/strong> if you update the software, how can you distribute the updates across the different instances?&lt;/li>
&lt;li>&lt;strong>Monitoring:&lt;/strong> how do you monitor multiple applications and aggregate the status of the service?&lt;/li>
&lt;li>&lt;strong>Resources:&lt;/strong> each instance requires its own resources and has to be managed independently.&lt;/li>
&lt;li>&lt;strong>Infrastructure constraints:&lt;/strong> where you deploy your application can also have an impact on its design. Indeed, if you deploy on a certain cloud provider some features/tools may be implemented differently or may not be accessible at all.&lt;/li>
&lt;/ul>
&lt;p>Standardization can avoid complex management. Having a replica instead of a custom version of your product per client will help.&lt;/p>
&lt;p>“Cloud lock” can be mitigated by containers, open-source, and avoiding cloud-native services.&lt;/p>
&lt;h2 id="distribution-isnt-integration">Distribution isn’t integration&lt;/h2>
&lt;p>After having built the software you want to distribute. Above we described two different ways to distribute it: SaaS or Bundle.&lt;/p>
&lt;p>Now how do you make your software &lt;strong>interact with the client system&lt;/strong>? This is the role of &lt;strong>integration&lt;/strong>. It does not impact your internal system but only the I/O of it. You can create many integrations to enable different use cases.&lt;/p>
&lt;p>&lt;strong>e.g.:&lt;/strong> API REST, S3 connector, Kafka, or even ipc, etc&lt;/p>
&lt;p>The integration part describes how your software will connect to the rest of the system. An integration can be different based on the way you choose to distribute the software. This step deals with the design and the architecture.&lt;/p>
&lt;h2 id="impacts">Impacts&lt;/h2>
&lt;p>The impacts of software distribution on the architecture:&lt;/p>
&lt;h3 id="cost">Cost&lt;/h3>
&lt;p>By building a service on your infrastructure, you have to manage the cost: cutting the bills becomes a real thing, resources usage is a concern. So you can combine services, use shared caching, &amp;hellip; This kind of cost reduction can be made with less friction when you manage the infrastructure.&lt;/p>
&lt;h3 id="move-fast">Move fast&lt;/h3>
&lt;p>Delegating tasks and adding vendors in the loop decrease the flexibility you have and create bottlenecks that can lead to slow iterations. If your product is deployed on-premise you will have to deal with the tech team of your client to make any fix or update.&lt;/p>
&lt;h3 id="security">Security&lt;/h3>
&lt;p>Security becomes a thing when you deploy on-premise, as you rely on the security of your customer infrastructure. But your tool can also bring security holes in their system. Miss-configuration due to a lack of knowledge of the targeted system becomes a real weakness. You have to take care of the security of the software you built but the infrastructure security will rely mostly on the customer.&lt;/p>
&lt;h3 id="intellectual-property">Intellectual Property&lt;/h3>
&lt;p>By the time you distribute the binary or the source code, you can’t protect yourself anymore against someone stealing your work. Only licenses, contracts, and laws can protect you against that. But the technical barriers are almost gone.&lt;/p>
&lt;p>Distributing your service through an API allows you to manage who can access it and they are only allowed to execute it, the intellectual property can be more protected with that form of distribution.&lt;/p>
&lt;h2 id="in-the-wild">In the wild&lt;/h2>
&lt;p>If you look at &lt;a href="http://sentry.io">Sentry.io&lt;/a> this tool is a perfect example, they chose to entirely &lt;a href="https://github.com/getsentry/sentry">open source&lt;/a> the product and they also provide Sentry as a SaaS. The product manages only one organization. To manage multiple organizations as they do for their SaaS, they have built other tools to manage multiple instances.&lt;/p>
&lt;p>GitLab has the same pattern, they have an open-source version and they have a cloud service you can directly subscribe to, and they manage the instance for you. The open-source version is only for one organization; if you want to have &lt;strong>multiple organizations you need to start new instances&lt;/strong>. So this is handled at an infrastructure level.&lt;/p>
&lt;h2 id="so-what">So what&lt;/h2>
&lt;p>&lt;em>Multi tenancy:&lt;/em>&lt;/p>
&lt;pre>&lt;code>+--------------------------------+
| Tenant 1 | Tenant 2 | Tenant 3 |
+--------------------------------+
| App |
+--------------------------------+
&lt;/code>&lt;/pre>&lt;p>or &lt;em>Single tenant:&lt;/em>&lt;/p>
&lt;pre>&lt;code>+--------------------------------+
| Tenant 1 | Tenant 2 | Tenant 3 |
+----------|----------|----------+
| App | App | App |
+--------------------------------+
&lt;/code>&lt;/pre>&lt;p>Build at an application level or at an infrastructure level requires different skills and has an impact on the team resource. This choice will have an effect down the line and need to be aligned with the business objectives.
&lt;br>
&lt;br>
&lt;br>
&lt;a href="https://twitter.com/YanaelBarbier">Discuss on Twitter&lt;/a>&lt;/p></description></item><item><title>Init</title><link>https://yanael.io/articles/init/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://yanael.io/articles/init/</guid><description>&lt;p>Everything starts with an init.&lt;/p>
&lt;p>It&amp;rsquo;s a perfect time to release my new project, Moonshot Engineer, a place where I can share my learnings and my views mostly about tech, startups, software, and data.&lt;/p>
&lt;h2 id="root-cause">Root cause&lt;/h2>
&lt;p>One thing I love the most is understanding how people work in their day to day basis. Jump in or starting a new project require to understand how the project works, what’s the purpose and goals of it, aligned with the philosophy behind it. From the outside we can see the inputs and the outputs, but the pipe between is most of the time hidden. Focus on the pipe, what’s inside, how things are made behind the hood? What were the decisions, the different proposals, the challenges, the methods, the tools, and why these choices were made?&lt;/p>
&lt;p>All of these questions are hard to answer when you don&amp;rsquo;t work with the team or in the company itself, and that&amp;rsquo;s what I want to discover, the unshared stories. One great thing is that, in the software community, open source is almost the root culture and, that can help us to explore and understand how things are made! So it will be one of the most used channels to try to understand stories.&lt;/p>
&lt;h2 id="behind-the-rocket">Behind the rocket&lt;/h2>
&lt;p>We have seen with the last SpaceX launch people interested in the software and the hardware that support this kind of technology. Some people tried to discover how things are made by aggregating conversations from engineers to understand how they implemented things. And discovering new technics and methods and maybe try to solve their problems with a different approach.&lt;/p>
&lt;h2 id="implementation">Implementation&lt;/h2>
&lt;p>That’s the question, how the implementation looks like? Two different projects can produce the same output but what’s the difference between those two, how they are built. At some point in a project, we face new challenges, and sometimes these challenges were already tackled by others and we can save time to directly ask them what works and what doesn’t. We don’t have to delegate or skip steps because it’s what makes us learn but avoiding getting stuck and having another point of view, that the thing. The actual learning will come when we start the implementation.&lt;/p>
&lt;h2 id="changelog">Changelog&lt;/h2>
&lt;p>We start with assumptions and lots of changes happen during the journey getting only the final state doesn’t lighten the full story. So logging the journey can help to understand the starting point and the path followed to reach the landing point.&lt;/p>
&lt;p>This place is where I will share my logs.&lt;/p>
&lt;h2 id="next-step">NeXT STEP&lt;/h2>
&lt;p>Let&amp;rsquo;s dig in!&lt;/p></description></item></channel></rss>